{"version":3,"file":"Input.js","sources":["../../src/utils/helpers.ts","../../src/utils/hooks.ts","../../src/utils/mutators.ts","../../src/utils/observables.ts","../../src/utils/index.ts","../../src/components/ReferenceWarnings.tsx","../../src/components/Input.tsx"],"sourcesContent":["/**\n *\n * @param type type prop passed by sanity to input components\n * @returns boolean defining whether the schema is an array or not\n */\nexport const isSchemaMulti = (type: InputType): boolean => {\n  return type.jsonType !== 'object'\n}\n\n/**\n *\n * @param type type prop passed by sanity to input components\n * @returns boolean defining whether the schema is a reference or not\n */\nexport const isSchemaReference = (type: InputType): boolean => {\n  return 'to' in type || ('of' in type && type.of[0] && 'to' in type.of[0])\n}\n\n/**\n *\n * @param tags an array of tags (i.e. { label: string, value: string })\n * @returns a filtered and flattened version of the initial tags array by uniqueness\n */\nexport const filterUniqueTags = (tags: Tag[]): Tag[] => {\n  if (!tags) tags = []\n\n  return tags.flat(Infinity).filter((firstTag, index) => {\n    const firstTagStringified = JSON.stringify({label: firstTag.label, value: firstTag.value})\n\n    return (\n      index ===\n      tags.flat(Infinity).findIndex((secondTag) => {\n        return (\n          JSON.stringify({label: secondTag.label, value: secondTag.value}) === firstTagStringified\n        )\n      })\n    )\n  })\n}\n\n/**\n * Get value from object through string/array path\n * @param obj The object with the key you want to retrieve\n * @param path The path (either a string or an array of strings) to the key (i.e. a.b.c or ['a', 'b', 'c'])\n * @param defaultValue A value to return\n * @returns The value at the end of the path or a default value\n */\nexport const get = <DefaultValue extends unknown>(\n  obj: Record<string, unknown> | unknown,\n  path: string | string[],\n  defaultValue?: DefaultValue\n): any => {\n  if (!obj) return defaultValue\n\n  let props: string[] | boolean = false\n  let prop: string | undefined\n\n  if (Array.isArray(path)) props = path.slice(0)\n  if (typeof path === 'string') props = path.split('.')\n  if (!Array.isArray(props)) throw new Error('path must be an array or a string')\n\n  while (props.length) {\n    prop = props.shift()\n    if (!prop) return defaultValue\n    if (!obj) return defaultValue\n    if (obj === null || typeof obj !== 'object' || Array.isArray(obj)) return defaultValue\n    if (!(prop in obj)) return defaultValue\n    obj = (obj as {[key: string]: unknown})[prop]\n  }\n\n  return obj\n}\n\n/**\n * Checks to make sure the prop passed is not a prototype\n * @param prop A string defining a prop\n * @returns True if not prototype, else false\n */\nfunction prototypeCheck(prop: string) {\n  if (prop === '__proto__' || prop === 'constructor' || prop === 'prototype') return false\n  return true\n}\n\n/**\n * Set value from object through string/array path\n * @param obj The object you want to add to\n * @param path The path to store the new value (either a string or an array of strings) to the key (i.e. a.b.c or ['a', 'b', 'c'])\n * @param value The value to add to the object\n * @returns True or false defining whether it is sucessfully added\n */\nexport const set = <Value extends unknown>(\n  obj: Record<string, unknown>,\n  path: string | string[],\n  value: Value\n): boolean => {\n  let props: string[] | boolean = false\n\n  if (Array.isArray(path)) props = path.slice(0)\n  if (typeof path === 'string') props = path.split('.')\n  if (!Array.isArray(props)) throw new Error('path must be an array or a string')\n\n  const lastProp = props.pop()\n  if (!lastProp) return false\n  if (!prototypeCheck(lastProp)) throw new Error('setting of prototype values not supported')\n\n  let thisProp: string | undefined\n  while ((thisProp = props.shift())) {\n    if (!prototypeCheck(thisProp)) throw new Error('setting of prototype values not supported')\n    if (!thisProp) return false\n    if (!(thisProp in obj)) obj[thisProp] = {}\n    obj = obj[thisProp] as Record<string, unknown>\n    if (!obj || typeof obj !== 'object') return false\n  }\n\n  obj[lastProp] = value\n\n  return true\n}\n","import React from 'react'\nimport {filterUniqueTags} from '../utils'\n\ntype LoadingOptions = {[key: string]: boolean}\ninterface UseLoadingInput {\n  initialLoadingOptions?: LoadingOptions\n  initialState?: boolean\n}\n\n/**\n * Expands on a basic `isLoading` state by allowing multiple keyed options with separate loading states to be tracked\n * @param initialLoadingOptions An object with several keys, each defining a boolean state of loaded/not loaded\n * @param initialState The initial state (whether or not it should start in a loading state or a loaded state)\n * @returns An array containing the overall loading state, the individual loading states, and a function to change the loading states respectively\n */\nexport const useLoading = ({\n  initialLoadingOptions = {},\n  initialState = true,\n}: UseLoadingInput): [boolean, LoadingOptions, (properties: LoadingOptions) => void] => {\n  const [loadingOptions, setLoadingOptions] = React.useState(initialLoadingOptions)\n  const [isLoading, setIsLoading] = React.useState(initialState)\n\n  React.useEffect(() => {\n    let loaded = false\n    if (Object.keys(loadingOptions).length) {\n      for (const option in loadingOptions) {\n        if (loadingOptions[option]) loaded = true\n      }\n    }\n\n    setIsLoading(loaded)\n  }, [loadingOptions])\n\n  const setLoadOption = React.useCallback((properties: LoadingOptions) => {\n    setLoadingOptions((oldValue) => {\n      return {...oldValue, ...properties}\n    })\n  }, [])\n\n  return [isLoading, loadingOptions, setLoadOption]\n}\n\ntype Options = {[key: string]: Tag[]}\ninterface UseOptionsInput {\n  initialState?: Tag[]\n}\n\n/**\n * Expands on a basic list of tag options by allowing groups of tags to be passed\n * @param initialState A list of tags (i.e. {label: string, value: string})\n * @returns An array containing a full list of tags, a list of tags keyed by respective groups, and a function to change/add a group of tag options respectively\n */\nexport const useOptions = ({\n  initialState = [],\n}: UseOptionsInput): [Tag[], Options, (properties: Options) => void] => {\n  const [options, setOptions] = React.useState(initialState)\n  const [groupOptions, setGroupOptions] = React.useState({} as Options)\n\n  React.useEffect(() => {\n    const opts: Tag[] = []\n    for (const group in groupOptions) {\n      if (Array.isArray(groupOptions[group])) opts.push(...groupOptions[group])\n    }\n\n    setOptions(filterUniqueTags(opts))\n  }, [groupOptions])\n\n  const setTagOption = React.useCallback((properties: Options) => {\n    setGroupOptions((oldValue) => ({...oldValue, ...properties}))\n  }, [])\n\n  return [options, groupOptions, setTagOption]\n}\n","import {client, get, set} from '.'\n\ninterface PrepareTagInput {\n  customLabel?: string\n  customValue?: string\n}\n\n/**\n * Prepares tags for react-select\n * @param customLabel a string with a custom label key to be swapped on the tag\n * @param customValue a string with a custom value key to be swapped on the tag\n * @returns a formatted tag that can be used with react-select without overriding custom labels or values\n */\nconst prepareTag = ({customLabel = 'label', customValue = 'value'}: PrepareTagInput) => {\n  return (tag: GeneralTag) => {\n    const tempTag: Tag = {\n      ...tag,\n      _label_temp: tag.label,\n      _value_temp: tag.value,\n      label: get(tag, customLabel),\n      value: get(tag, customValue),\n    }\n    return tempTag\n  }\n}\n\ninterface RevertTagInput<IsReference extends boolean = boolean> {\n  customLabel?: string\n  customValue?: string\n  isReference: IsReference\n}\n\n/**\n * Reverts tag for saving to sanity\n * @param customLabel a string with a custom label key to be swapped on the tag\n * @param customValue a string with a custom value key to be swapped on the tag\n * @param isReference whether or not the tag should be saved as a reference or an object\n * @returns a formatted tag that restores any custom labels or values while also preparing the tag to be saved by sanity\n */\nfunction revertTag<IsReference extends true>(\n  params: RevertTagInput<IsReference>\n): (tag: Tag) => RefTag\nfunction revertTag<IsReference extends false>(\n  params: RevertTagInput<IsReference>\n): (tag: Tag) => GeneralTag\nfunction revertTag<IsReference extends boolean>(\n  params: RevertTagInput<IsReference>\n): (tag: Tag) => RefTag | GeneralTag\nfunction revertTag<IsReference extends boolean>({\n  customLabel = 'label',\n  customValue = 'value',\n  isReference,\n}: RevertTagInput<IsReference>) {\n  return (tag: Tag): RefTag | GeneralTag => {\n    if (isReference === true) {\n      const tempTag: RefTag = {\n        _ref: tag._id,\n        _type: 'reference',\n      }\n\n      return tempTag\n    }\n\n    const tempTag: GeneralTag = {\n      ...tag,\n      label: tag._label_temp,\n      value: tag._value_temp,\n    }\n\n    set(tempTag, customLabel, tag.label)\n    set(tempTag, customValue, tag.value)\n\n    delete tempTag._label_temp\n    delete tempTag._value_temp\n    if (tempTag.label === undefined) delete tempTag.label\n    if (tempTag.value === undefined) delete tempTag.value\n\n    return tempTag\n  }\n}\n\ninterface PrepareTagsInput<TagType extends UnrefinedTags = UnrefinedTags> {\n  tags: TagType\n  customLabel?: string\n  customValue?: string\n}\n\n/**\n * Prepares a list of tag(s) for react-select\n * @param tags A list of tags that need to be prepared for react-select (general objects or references)\n * @returns A prepared list of tag(s) that preserves any custom labels or values\n */\nexport const prepareTags = async <TagType extends UnrefinedTags>({\n  tags,\n  customLabel = 'label',\n  customValue = 'value',\n}: PrepareTagsInput<TagType>): Promise<RefinedTags> => {\n  const prepare = prepareTag({customLabel, customValue})\n\n  // undefined single\n  if (tags === undefined || tags === null) return undefined\n\n  // undefined array\n  if (Array.isArray(tags) && !tags.length) return []\n\n  // reference array\n  if (Array.isArray(tags) && '_ref' in tags[0] && '_type' in tags[0])\n    if ('_ref' in tags[0] && '_type' in tags[0]) {\n      return (\n        await client.fetch('*[_id in $refs]', {\n          refs: tags.map((tag) => tag._ref),\n        })\n      ).map(prepare)\n    }\n\n  // object array\n  if (Array.isArray(tags)) return tags.map(prepare)\n\n  // reference singleton\n  if ('_ref' in tags && '_type' in tags)\n    return prepare(await client.fetch('*[_id == $ref][0]', {ref: tags._ref}))\n\n  // object singleton\n  return prepare(tags)\n}\n\n/**\n * Prepares a list of tags for react-select\n * @param tags A list of tags or single tag that need to be prepared for react-select (general objects or references)\n * @returns A prepared list of tags that preserves any custom labels or values\n */\nexport const prepareTagsAsList = async <TagType extends UnrefinedTags>(\n  preparedTagsOptions: PrepareTagsInput<TagType>\n): Promise<Tag[]> => {\n  const preparedTags = await prepareTags(preparedTagsOptions)\n\n  if (preparedTags === undefined) return []\n  if (!Array.isArray(preparedTags)) return [preparedTags]\n  return preparedTags\n}\n\ninterface RevertTagsInput<\n  IsReference extends boolean = boolean,\n  IsMulti extends boolean = boolean\n> {\n  tags: RefinedTags\n  customLabel?: string\n  customValue?: string\n  isMulti: IsMulti\n  isReference: IsReference\n}\n\n/**\n * Reverts tag(s) for saving to sanity\n * @param customLabel a string with a custom label key to be swapped on the tag(s)\n * @param customValue a string with a custom value key to be swapped on the tag(s)\n * @param isReference whether or not the tag(s) should be saved as a reference or an object\n * @returns a formatted list of tag(s) that restores any custom labels or values while also preparing the tag(s) to be saved by sanity\n */\nexport function revertTags<IsReference extends true, IsMulti extends true>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): RefTag[]\nexport function revertTags<IsReference extends true, IsMulti extends false>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): RefTag | undefined\nexport function revertTags<IsReference extends false, IsMulti extends true>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): GeneralTag[]\nexport function revertTags<IsReference extends false, IsMulti extends false>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): GeneralTag | undefined\nexport function revertTags<IsReference extends boolean, IsMulti extends false>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): RefTag | GeneralTag | undefined\nexport function revertTags<IsReference extends boolean, IsMulti extends true>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): RefTag[] | GeneralTag[]\nexport function revertTags<IsReference extends false, IsMulti extends boolean>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): GeneralTag | GeneralTag[] | undefined\nexport function revertTags<IsReference extends true, IsMulti extends boolean>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): RefTag | RefTag[] | undefined\nexport function revertTags<IsReference extends boolean, IsMulti extends boolean>(\n  params: RevertTagsInput<IsReference, IsMulti>\n): UnrefinedTags\nexport function revertTags<IsReference extends boolean, IsMulti extends boolean>({\n  tags,\n  customLabel = 'label',\n  customValue = 'value',\n  isMulti,\n  isReference,\n}: RevertTagsInput<IsReference, IsMulti>): UnrefinedTags {\n  const revert = revertTag({customLabel, customValue, isReference})\n\n  // if tags are undefined\n  if (tags === undefined) return undefined\n\n  if (isMulti) {\n    // ensure it is actually an array\n    if (!Array.isArray(tags)) tags = [tags]\n\n    // revert and return array\n    return tags.map(revert)\n  }\n\n  // not multi, so ensure is a single tag\n  if (Array.isArray(tags)) tags = tags[0]\n\n  // revert tag\n  return revert(tags)\n}\n","import {prepareTagsAsList, client, listenOptions, filterUniqueTags} from '../utils'\nimport {from, defer, pipe, Observable} from 'rxjs'\nimport {map, switchMap} from 'rxjs/operators'\n\ninterface RefineTagsPipeInput {\n  customLabel?: string\n  customValue?: string\n}\n\n/**\n * A custom pipe function that can be used in an observable pipe to refine tags\n * @param customLabel a string with a custom label key to be swapped on the tag(s)\n * @param customValue a string with a value label key to be swapped on the tag(s)\n * @returns A custom pipe function\n */\nconst refineTagsPipe = ({customLabel = 'label', customValue = 'value'}: RefineTagsPipeInput) =>\n  pipe(\n    map((val) => (Array.isArray(val) ? val.flat(Infinity) : val) as UnrefinedTags),\n    switchMap((val) => prepareTagsAsList({tags: val, customLabel, customValue})),\n    map((val) => filterUniqueTags(val))\n  )\n\ninterface GetGeneralObservableInput {\n  query: string\n  params: {\n    [key: string]: any\n  }\n  customLabel?: string\n  customValue?: string\n}\n\n/**\n * A generic observable that will watch a query and return refined tags\n * @param query A GROQ query for the sanity client\n * @param params A list of GROQ params for the sanity client\n * @param customLabel a string with a custom label key to be swapped on the tag(s)\n * @param customValue a string with a value label key to be swapped on the tag(s)\n * @returns An observable that watches for any changes on the query and params\n */\nconst getGeneralObservable = ({\n  query,\n  params,\n  customLabel = 'label',\n  customValue = 'value',\n}: GetGeneralObservableInput) => {\n  return client.listen<UnrefinedTags>(query, params, listenOptions).pipe(\n    switchMap(() => client.fetch<UnrefinedTags>(query, params)),\n    refineTagsPipe({customLabel, customValue})\n  )\n}\n\ninterface GetSelectedTagsInput<IsMulti extends boolean = boolean> {\n  tags: UnrefinedTags\n  isMulti: IsMulti\n  customLabel?: string\n  customValue?: string\n}\n\n/**\n * Manipulate the selected tags into a list of refined tags\n * @param tags A list or singleton of RefTag or GeneralTag that will act as the selected tags for react-select\n * @param customLabel a string with a custom label key to be swapped on the tag(s)\n * @param customValue a string with a value label key to be swapped on the tag(s)\n * @returns An observable that returns pre-refined tags received from the predefined tags option\n */\nexport function getSelectedTags<IsMulti extends true>(\n  params: GetSelectedTagsInput<IsMulti>\n): Observable<Tag[]>\nexport function getSelectedTags<IsMulti extends false>(\n  params: GetSelectedTagsInput<IsMulti>\n): Observable<Tag>\nexport function getSelectedTags<IsMulti extends boolean>(\n  params: GetSelectedTagsInput<IsMulti>\n): Observable<Tag | Tag[]>\nexport function getSelectedTags<IsMulti extends boolean>({\n  tags,\n  isMulti,\n  customLabel = 'label',\n  customValue = 'value',\n}: GetSelectedTagsInput<IsMulti>): Observable<Tag | Tag[]> {\n  const tagFunction = async () => tags\n  return defer(() => from(tagFunction())).pipe(\n    refineTagsPipe({customLabel, customValue}),\n    map((val) => (isMulti ? val : val[0]))\n  )\n}\n\n/**\n * Takes a function that can possibly return singleton tags and forces it to return an array of tags\n * @param predefinedTags A function that returns an unrefined tag(s)\n * @returns A list of the tags\n */\nconst predefinedTagWrapper = async (\n  predefinedTags:\n    | (() => Promise<GeneralTag | GeneralTag[] | RefTag | RefTag[]>)\n    | (() => GeneralTag | GeneralTag[] | RefTag | RefTag[])\n): Promise<GeneralTag[] | RefTag[]> => {\n  const tags = await predefinedTags()\n  if (!Array.isArray(tags)) return [tags]\n  return tags\n}\n\ninterface GetPredefinedTagsInput {\n  predefinedTags: PredefinedTags\n  customLabel?: string\n  customValue?: string\n}\n\n/**\n * Manipulate the predefined tags into a list of refined tags\n * @param predefinedTags A list or singleton of RefTag or GeneralTag that will act as predefined tags for react-select\n * @param customLabel a string with a custom label key to be swapped on the tag(s)\n * @param customValue a string with a value label key to be swapped on the tag(s)\n * @returns An observable that returns pre-refined tags received from the predefined tags option\n */\nexport const getPredefinedTags = ({\n  predefinedTags,\n  customLabel = 'label',\n  customValue = 'value',\n}: GetPredefinedTagsInput): Observable<Tag[]> => {\n  const tagFunction =\n    predefinedTags instanceof Function ? predefinedTags : async () => predefinedTags\n\n  return defer(() =>\n    from(predefinedTagWrapper(tagFunction)).pipe(refineTagsPipe({customLabel, customValue}))\n  )\n}\n\ninterface GetTagsFromReferenceInput {\n  document: string\n  customLabel?: string\n  customValue?: string\n}\n\n/**\n * Observes changes to a referenced document and returns refined tags\n * @param document a string that matches a document type in the sanity schema\n * @param customLabel a string with a custom label key to be swapped on the tag(s)\n * @param customValue a string with a value label key to be swapped on the tag(s)\n * @returns An observable that returns pre-refined tags received from the referenced document\n */\nexport const getTagsFromReference = ({\n  document,\n  customLabel = 'label',\n  customValue = 'value',\n}: GetTagsFromReferenceInput): Observable<Tag[]> => {\n  const query = `\n  *[ _type == $document && defined(@[$customLabel]) && defined(@[$customValue])] {\n    _id,\n    \"value\": @[$customValue],\n    \"label\": @[$customLabel]\n  }\n  `\n\n  const params = {\n    document,\n    customLabel: customLabel.split('.')[0],\n    customValue: customValue.split('.')[0],\n  }\n\n  return getGeneralObservable({\n    query,\n    params,\n    customLabel,\n    customValue,\n  })\n}\n\ninterface GetTagsFromRelatedInput {\n  document: string\n  field: string\n  isMulti: boolean\n  customLabel?: string\n  customValue?: string\n}\n\n/**\n * Observes changes to related objects and returns refined tags\n * @param document a string that matches the current document type\n * @param field a string that matches the name of the field to pull from\n * @param isMulti whether or not the related field is an array or an object\n * @param customLabel a string with a custom label key to be swapped on the tag(s)\n * @param customValue a string with a value label key to be swapped on the tag(s)\n * @returns An observable that returns pre-refined tags received from the related field within the document\n */\nexport const getTagsFromRelated = ({\n  document,\n  field,\n  isMulti,\n  customLabel = 'label',\n  customValue = 'value',\n}: GetTagsFromRelatedInput): Observable<Tag[]> => {\n  const query = `\n  *[\n    _type == $document &&\n    defined(@[$field]) &&\n    defined(@[$field][]) == $isMulti &&\n    (\n      (!$isMulti && defined(@[$field]->[$customLabel]) && defined(@[$field]->[$customValue])) ||\n      (!$isMulti && defined(@[$field][$customLabel]) && defined(@[$field][$customValue])) ||\n      ($isMulti && defined(@[$field][]->[$customLabel]) && defined(@[$field][]->[$customValue])) ||\n      ($isMulti && defined(@[$field][][$customLabel]) && defined(@[$field][][$customValue]))\n    ) \n  ][$field]\n  `\n\n  const params = {\n    document,\n    field,\n    isMulti,\n    customLabel: customLabel.split('.')[0],\n    customValue: customValue.split('.')[0],\n  }\n\n  return getGeneralObservable({\n    query,\n    params,\n    customLabel,\n    customValue,\n  })\n}\n","import sanityClient from 'part:@sanity/base/client'\nimport type {ListenOptions} from '@sanity/client'\n\nexport {filterUniqueTags, isSchemaReference, isSchemaMulti, get, set} from './helpers'\nexport {useLoading, useOptions} from './hooks'\nexport {prepareTags, prepareTagsAsList, revertTags} from './mutators'\nexport {\n  getSelectedTags,\n  getPredefinedTags,\n  getTagsFromReference,\n  getTagsFromRelated,\n} from './observables'\n\n/**\n * The default sanity client implemented by the sanity studio using API Version `2022-03-28`\n */\nexport const client = sanityClient.withConfig({\n  apiVersion: '2022-03-28',\n})\n\n/**\n * Default listen options to be used with the `listen` method provided by the sanity client\n */\nexport const listenOptions: ListenOptions = {\n  includeResult: false,\n  includePreviousRevision: false,\n  visibility: 'query',\n  events: ['welcome', 'mutation', 'reconnect'],\n}\n","import React from 'react'\nimport {Card} from '@sanity/ui'\n\nexport const ReferenceCreateWarning = () => (\n  <Card padding={[3, 3, 4]} marginBottom={[3, 3, 4]} radius={2} shadow={1} tone=\"caution\">\n    Tag References cannot be created inline. Please set the <code>allowCreate</code> option\n    explicitly to <code>false</code> to remove this warning message.\n  </Card>\n)\n\nexport const ReferencePredefinedWarning = () => (\n  <Card padding={[3, 3, 4]} marginBottom={[3, 3, 4]} radius={2} shadow={1} tone=\"caution\">\n    Tag References cannot have predefined tags. Please unset the <code>predefinedTags</code> option\n    to remove this warning message.\n  </Card>\n)\n","import React from 'react'\nimport {FormField} from '@sanity/base/components'\nimport PatchEvent, {\n  set as setPatchValue,\n  unset as unsetPatchValue,\n} from '@sanity/form-builder/PatchEvent'\nimport {useId} from '@reach/auto-id'\nimport CreatableSelect from 'react-select/creatable'\nimport Select from 'react-select'\n\nimport {withDocument} from 'part:@sanity/form-builder'\nimport CustomSelectComponents from 'part:tags/components/select'\n\nimport {\n  isSchemaMulti,\n  isSchemaReference,\n  useLoading,\n  useOptions,\n  prepareTags,\n  revertTags,\n  getSelectedTags,\n  getPredefinedTags,\n  getTagsFromReference,\n  getTagsFromRelated,\n  set,\n} from '../utils'\n\nimport {ReferenceCreateWarning, ReferencePredefinedWarning} from './ReferenceWarnings'\n\n// TODO: Allow reference creation inline\n// TODO: Allow reference merging inline (stretch ??)\n// TODO: Allow reference editing inline (stretch ??)\n// TODO: Allow reference deleting inline (stretch ??)\n// TODO: Allow object merging inline (stretch ??)\n// TODO: Allow object editing inline (stretch ??)\n// TODO: Allow object deleting inline (stretch ??)\n\nexport default withDocument(\n  React.forwardRef<HTMLInputElement, InputProps>((props, ref: any) => {\n    const [selected, setSelected] = React.useState<RefinedTags>(undefined)\n    const [isLoading, , setLoadOption] = useLoading({})\n    const [options, , setTagOption] = useOptions({})\n\n    const {\n      type, // Schema information\n      value, // Current field value\n      readOnly, // Boolean if field is not editable\n      markers, // Markers including validation rules\n      presence, // Presence information for collaborative avatars\n      onFocus, // Method to handle focus state\n      onBlur, // Method to handle blur state\n      onChange, // Method to handle patch events\n      document, // The current document\n    } = props\n\n    // get schema types (whether or not array, whether or not reference)\n    const isMulti = isSchemaMulti(type)\n    const isReference = isSchemaReference(type)\n\n    // define all options passed to input\n    const {\n      predefinedTags = [],\n      includeFromReference = false,\n      includeFromRelated = false,\n      customLabel = 'label',\n      customValue = 'value',\n      allowCreate = true,\n      onCreate = async (val: string): Promise<GeneralTag> => {\n        const tag: GeneralTag = {}\n        set(tag, customLabel, val)\n        set(tag, customValue, val)\n        return tag\n      },\n      checkValid = (inputValue: string, currentValues: string[]) =>\n        !currentValues.includes(inputValue) && !!inputValue && inputValue.trim() === inputValue,\n      reactSelectOptions = {} as SelectProps<typeof isMulti>,\n    } = type.options ? type.options : {}\n\n    // check if reference warnings need to be generated\n    const isReferenceCreateWarning = type.options && allowCreate && isReference\n    const isReferencePredefinedWarning =\n      type.options && !!type.options.predefinedTags && isReference\n\n    // get all tag types when the component loads\n    React.useEffect(() => {\n      // set generic unsubscribe function in case not used later on\n      const defaultSubscription = {\n        unsubscribe: () => {},\n      }\n\n      let selectedSubscription: GeneralSubscription = defaultSubscription\n      let predefinedSubscription: GeneralSubscription = defaultSubscription\n      let relatedSubscription: GeneralSubscription = defaultSubscription\n      let referenceSubscription: GeneralSubscription = defaultSubscription\n\n      // set the loading state for each option group\n      setLoadOption({\n        selectedTags: true,\n        predefinedTags: true,\n        referenceTags: true,\n        relatedTags: true,\n      })\n\n      // setup the selected observable\n      selectedSubscription = getSelectedTags({\n        tags: value,\n        customLabel,\n        customValue,\n        isMulti,\n      }).subscribe((tags) => {\n        setSelected(tags)\n        setLoadOption({selectedTags: false})\n      })\n\n      // setup the predefined observable\n      predefinedSubscription = getPredefinedTags({\n        predefinedTags,\n        customLabel,\n        customValue,\n      }).subscribe((tags) => {\n        setTagOption({predefinedTags: tags})\n        setLoadOption({predefinedTags: false})\n      })\n\n      // if true, setup the reference observable\n      if (typeof includeFromReference === 'string') {\n        referenceSubscription = getTagsFromReference({\n          document: includeFromReference,\n          customLabel,\n          customValue,\n        }).subscribe((tags) => {\n          setTagOption({referenceTags: tags})\n          setLoadOption({referenceTags: false})\n        })\n      } else {\n        setLoadOption({referenceTags: false})\n      }\n\n      // if true, setup the related observable\n      if (typeof includeFromRelated === 'string') {\n        relatedSubscription = getTagsFromRelated({\n          document: document._type,\n          field: includeFromRelated,\n          isMulti,\n          customLabel,\n          customValue,\n        }).subscribe((tags) => {\n          setTagOption({relatedTags: tags})\n          setLoadOption({relatedTags: false})\n        })\n      } else {\n        setLoadOption({relatedTags: false})\n      }\n\n      // unsubscribe on unmount\n      return () => {\n        selectedSubscription.unsubscribe()\n        predefinedSubscription.unsubscribe()\n        relatedSubscription.unsubscribe()\n        referenceSubscription.unsubscribe()\n      }\n    }, [])\n\n    // when new options are created, use this to handle it\n    const handleCreate = React.useCallback(\n      async (inputValue: string) => {\n        // since an await is used, briefly set the load state to true\n        setLoadOption({handleCreate: true})\n\n        // prepare the tag based on the option onCreate\n        const newCreateValue = await prepareTags({\n          customLabel,\n          customValue,\n          tags: await onCreate(inputValue),\n        })\n\n        // now that the option is created, pass to the handleChange function\n        if (Array.isArray(selected)) handleChange([...selected, newCreateValue] as RefinedTags)\n        else handleChange(newCreateValue)\n\n        // unset the load state\n        setLoadOption({handleCreate: false})\n      },\n      [onChange, selected]\n    )\n\n    // handle any change made to the select\n    const handleChange = React.useCallback(\n      (inputValue: RefinedTags) => {\n        // set the new option\n        setSelected(inputValue)\n\n        // revert the tags to their initial values for saving\n        const tagsForEvent = revertTags({\n          tags: inputValue,\n          customLabel,\n          customValue,\n          isMulti,\n          isReference,\n        })\n\n        // save the values\n        onChange(\n          PatchEvent.from(\n            tagsForEvent ? setPatchValue(tagsForEvent) : unsetPatchValue(tagsForEvent)\n          )\n        )\n      },\n      [onChange]\n    )\n\n    // create a unique id\n    const inputId = useId()\n\n    // set up the options for react-select\n    const selectOptions = {\n      isLoading,\n      onFocus,\n      onBlur,\n      ref,\n      inputId,\n      isMulti,\n      options,\n      value: selected,\n      isValidNewOption: (inputValue: string, selectedValues: Tag[], selectedOptions: Tag[]) => {\n        return checkValid(inputValue, [\n          ...selectedOptions.map((opt) => opt.value),\n          ...selectedValues.map((val) => val.value),\n        ])\n      },\n      onCreateOption: handleCreate,\n      onChange: handleChange,\n      isDisabled: readOnly || isLoading,\n      ...reactSelectOptions,\n    } as SelectProps\n\n    // return the Select Component\n    return (\n      <FormField\n        description={type.description}\n        title={type.title}\n        __unstable_markers={markers}\n        __unstable_presence={presence}\n        inputId={inputId}\n      >\n        {isReferenceCreateWarning && <ReferenceCreateWarning />}\n        {isReferencePredefinedWarning && <ReferencePredefinedWarning />}\n        {allowCreate && !isReference ? (\n          <CreatableSelect\n            {...selectOptions}\n            components={CustomSelectComponents as SelectComponents}\n          />\n        ) : (\n          <Select {...selectOptions} components={CustomSelectComponents as SelectComponents} />\n        )}\n      </FormField>\n    )\n  })\n)\n"],"names":["setPatchValue","unsetPatchValue"],"mappings":"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"}